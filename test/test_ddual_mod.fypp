#:mute

#:include '../src/macros/dnad_dual_type.fypp'
#:include '../src/macros/dnad_interfaces.fypp'
#:include '../src/macros/dnad_implementations.fypp'

#: set number_of_derivatives = 2
#: set has_double_dual = True

#! When set_undefined = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When set_undefined = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using set_undefined = False is 
#! believed to be faster.
#:set set_undefined = False

#! selected_interfaces is a comma separated list or "--all"
#:set selected_interfaces = "=,+,-,*,/,**,log,sqrt"

#:endmute
module test_ddual_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    integer, parameter :: num_deriv = ${number_of_derivatives}$

  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    @:dnad_dual_type(dual_xy, dp, num_deriv, sequence, ddual_xy)

    @:dnad_interfaces(${selected_interfaces}$, ${has_double_dual}$)
    
contains

    function test_ddual() result(is_ok)
        logical :: is_ok
           
        integer, parameter :: nval = 1

        integer :: i

        real(dp), dimension(nval) :: x, y
        real(dp), dimension(nval) :: f, f_fasit
        real(dp), dimension(2, nval) :: df, df_fasit
        real(dp), dimension(2, 2, nval) :: ddf, ddf_fasit

        type(ddual_xy), dimension(nval) :: xdd, ydd, fdd
        type(dual_xy), dimension(nval) :: xd, xxd, xyd, yd, d, yyd

        call random_number(x)
        call random_number(y)

        ! Initialize dual inputs:
        do i = 1, nval
            xdd(i)%x = x(i)
            xdd(i)%dx(1)%x       = 1.0_dp    ! dx/dx
            xdd(i)%dx(1)%dx(1:2) = [1.0_dp, 0.0_dp]         ! [d**2x/dx**2, d**2x/dxdy] 
            xdd(i)%dx(2)%x       = 0         ! dx/dy
            xdd(i)%dx(2)%dx(1:2) = [0.0_dp, 0.0_dp]         ! [d**2x/dxdy, d**2x/dydy] 

            ydd(i)%x = y(i)
            ydd(i)%dx(1)%x       = 0         ! dy/dx
            ydd(i)%dx(1)%dx(1:2) = [0.0_dp, 0.0_dp]         ! [d**2y/dx**2, d**2y/dxdy] 
            ydd(i)%dx(2)%x       = 1.0_dp    ! dy/dy
            ydd(i)%dx(2)%dx(1:2) = [0.0_dp, 1.0_dp]         ! [d**2y/dxdy, d**2y/dy**2] 

            xd(i)  = dual_xy(x(i)  , [1.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp])
            xxd(i) = dual_xy(1.0_dp, [0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp])
            xyd(i) = dual_xy(0.0_dp, [0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp])
            yd(i)  = dual_xy(y(i)  , [0.0_dp, 0.0_dp, 0.0_dp, 1.0_dp, 0.0_dp, 0.0_dp])
            yxd(i) = dual_xy(0.0_dp, [0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp])
            yyd(i) = dual_xy(1.0_dp, [0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp, 0.0_dp])

        end do

        do i = 1, nval
            fdd(i) = test_function_ddual_wrap(xd(i), xxd(i), xyd(i), yd(i), yxd(i), yyd(i))
        end do

        ! Extract function value, gradient and hessian for all values:
        do i = 1, nval
            f(i) = fd(i)
            df(1, i) = fd(i)%dx(1)%x
            df(2, i) = fd(i)%dx(2)%x
            ddf(1, 1, i) = fd(i)%dx(1)%dx(1)
            ddf(2, 1, i) = fd(i)%dx(2)%dx(1)
            ddf(1, 2, i) = fd(i)%dx(1)%dx(2)
            ddf(2, 2, i) = fd(i)%dx(2)%dx(2)
        end do

        ! Fasit:
        do i = 1, nval
            call test_function_analytic(x(i), y(i), f_fasit(i), df_fasit(:, i), ddf_fasit(:, :, i))
        end do

        print*, "f:"
        print*, f
        print*, "f_fasit:"
        print*, f_fasit
        print*, "df:"
        print*, df
        print*, "df_fasit:"
        print*, df_fasit
        print*, "ddf:"
        print*, ddf
        print*, "ddf_fasit:"
        print*, ddf_fasit
      
    end function

    pure function test_function_ddual_wrap(x, xx, xy, y, yx, yy) result(fd)
        type(dual_xy), intent(in) :: x, xx, xy, y, yx, yy
        type(dual_xy) :: fd

        type(ddual_xy) :: xd, yd

        xd%x = x
        xd%dx = [xx, xy]
        yd%x = y
        yd%dx = [yx, yy]

        fd = test_function_ddual(x, y)
    end function

    pure function test_function_ddual(x, y) result(f)
        type(ddual_xy), intent(in) :: x, y
        type(ddual_xy) :: f
        f = sqrt(x)*log(y)
    end function

    pure subroutine test_function_analytic(x, y, f, df, ddf)
        real(dp), intent(in) :: x, y
        real(dp), intent(out) :: f           ! function value
        real(dp), intent(out) :: df(2)       ! gradient
        real(dp), intent(out) :: ddf(2, 2)   ! Hessian
        f = sqrt(x)*log(y)
        df(1) = log(y)/(2*sqrt(x))  ! df/dx
        df(2) = sqrt(x)/y           ! df/dy
        ddf(1, 1) = -log(y)/(4*x**1.5_dp)  ! d**2f/dx**2
        ddf(2, 2) = -sqrt(x)/(y**2)        ! d**2f/dy**2
        ddf(2, 1) = 1/(2*sqrt(x)*y)        ! d**2f/dxdy
        ddf(1, 2) = ddf(2, 1)              ! d**2f/dydx
    end subroutine

    @:dnad_implementations(dual_xy, dp, num_deriv, ${selected_interfaces}$, ${set_undefined}$, ddual_xy)

  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module