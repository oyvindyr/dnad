#:mute

#:include '../src/macros/dnad_dual_type.fypp'
#:include '../src/macros/dnad_interfaces.fypp'
#:include '../src/macros/dnad_implementations.fypp'

#: set number_of_derivatives = 2
#: set has_double_dual = True

#! When set_undefined = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When set_undefined = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using set_undefined = False is 
#! believed to be faster.
#:set set_undefined = False

#! selected_interfaces is a comma separated list or "--all"
#:set selected_interfaces = "=,+,-,*,/,**,log,sqrt"

#:endmute
module test_ddual_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    integer, parameter :: num_deriv = ${number_of_derivatives}$

  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    @:dnad_dual_type(dual_xy, dp, num_deriv, sequence, ddual_xy)

    @:dnad_interfaces(${selected_interfaces}$, ${has_double_dual}$)
    
contains

    function test_ddual() result(is_ok)
        logical :: is_ok
           
        integer, parameter :: nval = 1

        integer :: i

        real(dp), dimension(nval) :: x, y
        real(dp), dimension(nval) :: f, f_fasit
        real(dp), dimension(2, nval) :: df, df_fasit
        real(dp), dimension(2, 2, nval) :: ddf, ddf_fasit

        type(ddual_xy), dimension(nval) :: xd, yd, fd

        call random_number(x)
        call random_number(y)

        ! Initialize dual inputs:
        do i = 1, nval
            xd(i)%x = x(i)
            xd(i)%dx(1)%x       = 1.0_dp    ! dx/dx
            xd(i)%dx(1)%dx(1:2) = 0         ! [d**2x/dx**2, d**2x/dxdy] 
            xd(i)%dx(2)%x       = 0         ! dx/dy
            xd(i)%dx(2)%dx(1:2) = 0         ! [d**2x/dxdy, d**2x/dydy] 

            yd(i)%x = y(i)
            yd(i)%dx(1)%x       = 0         ! dy/dx
            yd(i)%dx(1)%dx(1:2) = 0         ! [d**2y/dx**2, d**2y/dxdy] 
            yd(i)%dx(2)%x       = 1.0_dp    ! dy/dy
            yd(i)%dx(2)%dx(1:2) = 0         ! [d**2y/dxdy, d**2y/dy**2] 

            ! xd(i)%x = x(i)
            ! xd(i)%dx(1)%x       = 1.0_dp    ! dx/dx
            ! xd(i)%dx(1)%dx(1:2) = [1.0_dp, 0.0_dp]         ! [d**2x/dx**2, d**2x/dxdy] 
            ! xd(i)%dx(2)%x       = 0         ! dx/dy
            ! xd(i)%dx(2)%dx(1:2) = [0.0_dp, 1.0_dp]         ! [d**2x/dxdy, d**2x/dydy] 

            ! yd(i)%x = y(i)
            ! yd(i)%dx(1)%x       = 0         ! dy/dx
            ! yd(i)%dx(1)%dx(1:2) = [1.0_dp, 0.0_dp]         ! [d**2y/dx**2, d**2y/dxdy] 
            ! yd(i)%dx(2)%x       = 1.0_dp    ! dy/dy
            ! yd(i)%dx(2)%dx(1:2) = [0.0_dp, 1.0_dp]         ! [d**2y/dxdy, d**2y/dy**2] 

        end do

        fd = test_function_ddual(xd, yd)

        ! Extract function value, gradient and hessian for all values:
        do i = 1, nval
            f(i) = fd(i)
            df(1, i) = fd(i)%dx(1)%x
            df(2, i) = fd(i)%dx(2)%x
            ddf(1, 1, i) = fd(i)%dx(1)%dx(1)
            ddf(2, 1, i) = fd(i)%dx(2)%dx(1)
            ddf(1, 2, i) = fd(i)%dx(1)%dx(2)
            ddf(2, 2, i) = fd(i)%dx(2)%dx(2)
        end do

        ! Fasit:
        do i = 1, nval
            call test_function_analytic(x(i), y(i), f_fasit(i), df_fasit(:, i), ddf_fasit(:, :, i))
        end do

        print*, "f:"
        print*, f
        print*, "f_fasit:"
        print*, f_fasit
        print*, "df:"
        print*, df
        print*, "df_fasit:"
        print*, df_fasit
        print*, "ddf:"
        print*, ddf
        print*, "ddf_fasit:"
        print*, ddf_fasit
      
    end function

    elemental function test_function_ddual(x, y) result(f)
        type(ddual_xy), intent(in) :: x, y
        type(ddual_xy) :: f
        f = sqrt(x)*log(y)
    end function

    pure subroutine test_function_analytic(x, y, f, df, ddf)
        real(dp), intent(in) :: x, y
        real(dp), intent(out) :: f           ! function value
        real(dp), intent(out) :: df(2)       ! gradient
        real(dp), intent(out) :: ddf(2, 2)   ! Hessian
        f = sqrt(x)*log(y)
        df(1) = log(y)/(2*sqrt(x))  ! df/dx
        df(2) = sqrt(x)/y           ! df/dy
        ddf(1, 1) = -log(y)/(4*x**1.5_dp)  ! d**2f/dx**2
        ddf(2, 2) = -sqrt(x)/(y**2)        ! d**2f/dy**2
        ddf(2, 1) = 1/(2*sqrt(x)*y)        ! d**2f/dxdy
        ddf(1, 2) = ddf(1, 2)              ! d**2f/dydx
    end subroutine

    @:dnad_implementations(dual_xy, dp, num_deriv, ${selected_interfaces}$, ${set_undefined}$, ddual_xy)

  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module