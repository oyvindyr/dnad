#:mute

#:include '../src/macros/dnad_dual_types.fypp'
#:include '../src/macros/dnad_overload_interfaces.fypp'
#:include '../src/macros/dnad_overload_implementations.fypp'
#:include '../src/macros/dnad_initialize.fypp'
#:include '../src/macros/dnad_hessian.fypp'
#:include '../src/macros/dnad_chain_duals.fypp'
#:include '../src/macros/dnad_display.fypp'

#! Include call counters to check test coverage:
#: set test_coverage = True

#! When stringent = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When stringent = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using stringent = False is 
#! believed to be faster.
#:set stringent = False

#! selected_interfaces is a comma separated list or "--all"
#!set selected_interfaces = "=,*,log,sqrt"
#:set selected_interfaces = "--all"

#:endmute
module test_hdual_chain_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    private
    public :: test_hdual_chain

    integer, parameter :: ny = 2
    integer, parameter :: nx = 3


    ! Implementation call counters to show test coverage:
  #:for impl in dnad.all_implementations
    integer :: ${impl+"_counter"}$ = 0
  #:endfor

  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    @:dnad_dual_type(dual_y_t, dp, ny, sequence)
    @:dnad_dual_type(dual_x_t, dp, nx, sequence)
    @:dnad_hdual_type(hdual_y_t, dp, ny, sequence)
    @:dnad_hdual_type(hdual_x_t, dp, nx, sequence)

    interface  f_of_y
        module procedure f_of_y__x ! Function of y, with derivatives wrt x
        module procedure f_of_y__y ! Function of y, with derivatives wrt y
    end interface

    $:dnad_initialize_interface(dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_display_interface(dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_hessian_interface(hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_chain_duals_interface(dual_y_names = ['dualy', 'hdualy'], dual_x_names = ['dualx', 'hdualx'])
    $:dnad_overload_interfaces(selected_interfaces, &
            dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    
contains

    function test_hdual_chain() result(is_ok)
        logical :: is_ok
           
        real(dp), parameter :: abs_tol = 1.0e-14_dp

        integer :: i

        real(dp) :: x(nx)

        type(hdual_y_t) :: fy
        type(hdual_y_t) :: yy(ny)

        type(hdual_x_t) :: fx
        type(hdual_x_t) :: yx(ny)
        type(hdual_x_t) :: xx(nx)

        type(hdual_x_t) :: fx_chain

        ! random x
        call random_number(x)
        x = 5*x + 0.1_dp
        call initialize(xx, x)
        
        ! y as a function of x, with derivatives wrt x
        yx = y_of_x(xx)

        ! y as a function of y, with derivatives wrt y
        call initialize(yy, yx(:)%x)

        ! f as a function of y, with derivatives wrt y
        fy = f_of_y(yy)

        ! f as a function of x, with derivatives wrt x
        fx_chain = chain_duals(fy, yx)

        ! Same as fx_chain, but computed directly
        fx = f_of_x(xx)

        print*," "
        call display(yy, "yy")
        print*," "
        call display(fx, fx_chain, "fx", "fx_chain")

        ! print*, "fun: ", fx%x, fx_chain%x, fx%x - fx_chain%x
        ! do i = 1, nx
        !     print*, "der: ", fx%dx(i), fx_chain%dx(i), fx%dx(i) - fx_chain%dx(i)
        ! end do
        ! do i = 1, size(fx%ddx)
        !     print*, "hess: ", fx%ddx(i), fx_chain%ddx(i), fx%ddx(i) - fx_chain%ddx(i)
        ! end do

        is_ok = .true.


    end function

    ! subroutine display(d1, d2, name1, name2)
    !     type(hdual_x_t), intent(in) :: d1
    !     type(hdual_x_t), intent(in) :: d2
    !     character(len=*), intent(in) :: name1
    !     character(len=*), intent(in) :: name2
    !     integer :: i, j, k

    !     ! fx%x         fx_chain%x
    !     ! -6.71560920418316E-01 -6.71560920418316E-01

    !     print*, "Function values:"
    !     print*, " ",name1, "%x                  ", name2, "%x"
    !     write(*,'(ES22.14, ES22.14)'), d1%x, d2%x

    !     print*, "Derivatives:"
    !     print*, " i    ", name1, "%dx(i)                ", name2, "%dx(i)"
    !     do i = 1, size(d1%dx)
    !         print '(I3, ES22.14, ES22.14)' , i, d1%dx(i), d2%dx(i)
    !     end do

    !     print*, "Lower triangular of Hessian matrix, h(i,j)"
    !     print*, " k  i  j   ", name1, "%ddx(k)            ", name2, "%ddx(k)"
    !     k = 0
    !     do j = 1, size(d1%dx)
    !         do i = j, size(d1%dx)
    !             k = k + 1
    !             print '(I3, I3, I3, ES22.14, ES22.14)', k, i, j, d1%ddx(k), d2%ddx(k)
    !         end do
    !     end do

    ! end subroutine

  #:for vd in ['x', 'y']
    function f_of_y__${vd}$(y) result(f)
        type(hdual_${vd}$_t), intent(in) :: y(ny)
        type(hdual_${vd}$_t) :: f
        f = sqrt(y(1))*log(y(2))
    end function
  #:endfor

    function y_of_x(x) result(y)
        type(hdual_x_t), intent(in) :: x(nx)
        type(hdual_x_t) :: y(ny)
        y(1) = sqrt(x(1)**2 + x(2)**2)
        y(2) = x(3)
    end function

    function f_of_x(x) result(f)
        type(hdual_x_t), intent(in) :: x(nx)
        type(hdual_x_t) :: f
        f = f_of_y(y_of_x(x))
    end function
    $:dnad_initialize_implementations("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_display_implementations(&
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_hessian_implementations("dp", &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_chain_duals_implementation('dual_y_t', 'dualy', 'dual_x_t', 'dualx', is_hyper_dual = False)
    $:dnad_chain_duals_implementation('hdual_y_t', 'hdualy', 'hdual_x_t', 'hdualx', is_hyper_dual = True)
    $:dnad_overload_implementations("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], dual_sizes = ['nx', 'ny'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'], hdual_sizes = ['nx', 'ny'], &
            selected_interfaces=selected_interfaces, stringent=stringent, &
            test_coverage=test_coverage)
    
  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module