#:mute

#:include '../src/macros/dnad_dual_types.fypp'
#:include '../src/macros/dnad_overload_interfaces.fypp'
#:include '../src/macros/dnad_overload_implementations.fypp'
#:include '../src/macros/dnad_initialize.fypp'
#:include '../src/macros/dnad_hessian.fypp'
#:include '../src/macros/dnad_jacobi_tr.fypp'
#:include '../src/macros/dnad_chain_duals.fypp'
#:include '../src/macros/dnad_display.fypp'


#! When stringent = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When stringent = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using stringent = False is 
#! believed to be faster.
#:set stringent = False

#! selected_interfaces is a comma separated list or "--all"
#:set selected_interfaces = "=,+,-,*,**,log,sqrt"
#!set selected_interfaces = "--all"

#:endmute
module test_hdual_chain_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    private
    public :: test_hdual_chain

    integer, parameter :: ny = 2
    integer, parameter :: nx = 3

  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    @:dnad_dual_type(dual_y_t, dp, ny, sequence)
    @:dnad_dual_type(dual_x_t, dp, nx, sequence)
    @:dnad_hdual_type(hdual_y_t, dp, ny, sequence)
    @:dnad_hdual_type(hdual_x_t, dp, nx, sequence)

    interface  f_of_y
        module procedure f_of_y__x ! Function of y, with derivatives wrt x
        module procedure f_of_y__y ! Function of y, with derivatives wrt y
    end interface

    $:dnad_initialize_interface(dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_display_interface(dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_hessian_interface(hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_jacobi_tr_interface(dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    $:dnad_chain_duals_interface(dual_y_names = ['dualy', 'hdualy'], dual_x_names = ['dualx', 'hdualx'])
    $:dnad_overload_interfaces(selected_interfaces, &
            dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    
contains

    function test_hdual_chain() result(is_ok)
        logical :: is_ok
           
        real(dp), parameter :: abs_tol = 1.0e-14_dp

        integer :: i

        real(dp) :: x(nx)

        type(hdual_y_t) :: fy
        type(hdual_y_t) :: yy(ny)

        type(hdual_x_t) :: fx
        type(hdual_x_t) :: yx(ny)
        type(hdual_x_t) :: xx(nx)

        type(hdual_x_t) :: fx_chain

        ! random x
        call random_number(x)
        x = 5*x + 0.1_dp

        ! Initialize xx, representing x as a function of x, with derivatives wrt x
        call initialize(xx, x)
        
        ! y as a function of x, with derivatives wrt x
        yx = y_of_x(xx)

        ! y as a function of y, with derivatives wrt y
        call initialize(yy, yx(:)%x)

        ! f as a function of y, with derivatives wrt y
        fy = f_of_y(yy)

        ! f as a function of x, with derivatives wrt x
        fx_chain = chain_duals(fy, yx)

        ! Same as fx_chain, but computed directly
        fx = f_of_x(xx)

        print*," "
        call display(yy, "yy")
        print*," "
        call display(fy, "fy")
        print*," "
        call display(fx, fx_chain, "fx", "fx_chain")


        print*," "
        call display(yx, "yx")
        print*," "
        call display(jacobi_tr(yx), "yxjt")

        is_ok = .true.
        if (abs(fx_chain%x - fx%x) > abs_tol) then
            is_ok = .false.
        end if
        if (maxval(abs(fx_chain%dx - fx%dx)) > abs_tol) then
            is_ok = .false.
        end if
        if (maxval(abs(fx_chain%ddx - fx%ddx)) > abs_tol) then
            is_ok = .false.
        end if

        


    end function

  #:for vd in ['x', 'y']
    function f_of_y__${vd}$(y) result(f)
        type(hdual_${vd}$_t), intent(in) :: y(ny)
        type(hdual_${vd}$_t) :: f
        f = sqrt(y(1))*log(y(2))
    end function
  #:endfor

    function y_of_x(x) result(y)
        type(hdual_x_t), intent(in) :: x(nx)
        type(hdual_x_t) :: y(ny)
        y(1) = sqrt(x(1)**2 + x(2)**2)
        y(2) = x(3)
    end function

    function f_of_x(x) result(f)
        type(hdual_x_t), intent(in) :: x(nx)
        type(hdual_x_t) :: f
        f = f_of_y(y_of_x(x))
    end function

    $:dnad_initialize_implementations("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_display_implementations(&
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_hessian_implementations("dp", &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'])
    $:dnad_jacobi_tr_implementations_hdual("dp", &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'], &
            dual_types  = ['dual_x_t', 'dual_y_t'])
    $:dnad_jacobi_tr_implementations_dual("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'])
    $:dnad_chain_duals_implementation('dual_y_t', 'dualy', 'dual_x_t', 'dualx', is_hyper_dual = False)
    $:dnad_chain_duals_implementation('hdual_y_t', 'hdualy', 'hdual_x_t', 'hdualx', is_hyper_dual = True)
    $:dnad_overload_implementations("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], dual_sizes = ['nx', 'ny'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'], hdual_sizes = ['nx', 'ny'], &
            selected_interfaces=selected_interfaces, stringent=stringent)
    
  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module