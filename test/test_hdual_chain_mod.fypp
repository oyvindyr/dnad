#:mute

#:include '../src/macros/dnad_dual_types.fypp'
#:include '../src/macros/dnad_interfaces.fypp'
#:include '../src/macros/dnad_implementations.fypp'

#! Include call counters to check test coverage:
#: set test_coverage = True

#! When stringent = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When stringent = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using stringent = False is 
#! believed to be faster.
#:set stringent = False

#! selected_interfaces is a comma separated list or "--all"
#!set selected_interfaces = "=,*,log,sqrt"
#:set selected_interfaces = "--all"

#:endmute
module test_hdual1_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    integer, parameter :: ny = 2
    integer, parameter :: nx = 3


    ! Implementation call counters to show test coverage:
  #:for impl in dnad.all_implementations
    integer :: ${impl+"_counter"}$ = 0
  #:endfor

  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    @:dnad_dual_type(dual_y_t, dp, ny, sequence)
    @:dnad_dual_type(dual_x_t, dp, nx, sequence)
    @:dnad_hdual_type(hdual_y_t, dp, ny, sequence)
    @:dnad_hdual_type(hdual_x_t, dp, nx, sequence)

    $:dnad_interfaces(selected_interfaces, &
            dual_shortnames = ['dualx', 'dualy'], hdual_shortnames=['hdualx', 'hdualy'])
    
contains

    function test_hdual_chain() result(is_ok)
        logical :: is_ok
           
        real(dp), parameter :: abs_tol = 1.0e-14_dp

        integer :: i

        real(dp) :: r
        real(dp) :: x(nx)
        real(dp) :: y(ny)

        type(dual_y_t) :: fy
        type(dual_y_t) :: yy(ny)

        type(dual_x_t) :: fx
        type(dual_x_t) :: yx(ny)
        type(dual_x_t) :: xx(nx)

        type(dual_x_t) :: fx_chain

        do i = 1, ny
            call random_number(y(i))
            y(i) = 5*y(i) + 0.1_dp
        enddo
        do i = 1, nx
            call random_number(x(i))
            x(i) = 5*x(i) + 0.1_dp
        enddo
        
        do i = 1, ny
            call initialize(yy(i), y(i), i)
        enddo
        do i = 1, nx
            call initialize(xx(i), x(i), i)
        enddo

        fy = f_of_y__y(yy)
        yx = y_of_x(xx)
        fx_chain = chain_duals(fy, yx)

        fx = f_of_x(xx)

        print*, "fun: ", fx%x, fx_chain%x
        do i = 1, nx
            print*, "der: ", fx%dx(i), fx_chain%dx(i)
        end do
        ! do i = 1, size(fx%ddx)
        !     print*, "hess: ", fx%ddx(i), fx_chain%ddx(i)
        ! end do


    end function

    function chain_duals(fy, yx) result(fx)
        type(dual_y_t), intent(in) :: fy
        type(dual_x_t), intent(in) :: yx(size(fy%dx))
        type(dual_x_t) :: fx
        
        integer :: ix, iy

        fx%x = fy%x
        fx%dx = 0
        do ix = 1, size(fx%dx)
            do iy = 1, size(fy%dx)
                fx%dx(ix) = fx%dx(ix) + fy%dx(iy)*yx(iy)%dx(ix)
            end do
        end do


    end function

    function f_of_y__y(y) result(f)
        type(dual_y_t), intent(in) :: y(2)
        type(dual_y_t) :: f
        f = sqrt(y(1))*log(y(2))
    end function
    function f_of_y__x(y) result(f)
        type(dual_x_t), intent(in) :: y(2)
        type(dual_x_t) :: f
        f = sqrt(y(1))*log(y(2))
    end function

    function y_of_x(x) result(y)
        type(dual_x_t), intent(in) :: x(3)
        type(dual_x_t) :: y(2)
        y(1) = sqrt(x(1)**2 + x(2)**2)
        y(2) = x(3)
    end function

    function f_of_x(x) result(f)
        type(dual_x_t), intent(in) :: x(3)
        type(dual_x_t) :: f
        f = f_of_y__x(y_of_x(x))
    end function

    $:dnad_implementations("dp", &
            dual_types = ['dual_x_t', 'dual_y_t'], dual_shortnames = ['dualx', 'dualy'], dual_sizes = ['nx', 'ny'], &
            hdual_types = ['hdual_x_t', 'hdual_y_t'], hdual_shortnames = ['hdualx', 'hdualy'], hdual_sizes = ['nx', 'ny'], &
            selected_interfaces=selected_interfaces, stringent=stringent, &
            test_coverage=test_coverage)
    
  #:if stringent
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module