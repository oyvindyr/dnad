#:mute

#:include '../src/macros/dnad_dual_types.fypp'
#:include '../src/macros/dnad_interfaces.fypp'
#:include '../src/macros/dnad_implementations.fypp'

#! When set_undefined = False, the dnad functions assume that the derivative exists. It is does not exist (for instance for abs(0.0))
#! the result will be undefined. When set_undefined = True (or not defined) some logic is included in the mathematical functions to
#! determine if the derivative exists of not, and call a function set_NaN() when it does not exist. Using set_undefined = False is 
#! believed to be faster.
#:set set_undefined = True

#! selected_interfaces is a comma separated list or "--all"
#:set selected_interfaces = "=,+,acos"

#:endmute
module example_dual_undef_mod
    use, intrinsic :: iso_fortran_env, only: dp => real64
    implicit none

    private
    public :: example_dual_undef

    integer, parameter :: num_deriv = 3 ! Number of derivatives

  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    real(dp) :: negative_one = -1.0_dp
  #:endif
    
    #! Inject the dual type definitions
    #!  Note: Calling a macro with @ will convert all arguments to strings
    @:dnad_dual_type(dual_uvw, dp, num_deriv, sequence)

    #! Inject interfaces
    #!  Note: Calling a macro with $ will send in python variables as arguments
    $:dnad_interfaces(selected_interfaces, has_dual=True)
    
contains

    subroutine example_dual_undef()

        type(dual_uvw) :: uhd, vhd, whd, fhd

        uhd = initialize_dual(1.0_dp, 1)
        vhd = initialize_dual(1.0_dp, 2)
        whd = initialize_dual(1.0_dp, 3)

        ! Function to compute value, gradient and Hessian for:
        fhd = test_function(uhd, vhd, whd)


        print *, "Function value:"
        print *, fhd%x

        print *, "Gradient:"
        print *, fhd%dx

    end subroutine

    elemental function test_function(u, v, w) result(f)
        type(dual_uvw), intent(in) :: u, v, w
        type(dual_uvw) :: f
        f = acos(u)
    end function

    #! Inject overloaded function implementations
    $:dnad_implementations("dp", "num_deriv", dual_type="dual_uvw", selected_interfaces=selected_interfaces, &
            set_undefined=set_undefined)
    
  #:if set_undefined
    ! Workaround to make pure functions produce NaN's deliberately:
    elemental function set_NaN() result(res)
        real(dp) :: res
        res = sqrt(negative_one)
    end function set_NaN
  #:endif
    
end module