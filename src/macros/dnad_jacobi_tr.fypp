#:def dnad_jacobi_tr_interface(type_specs)
    interface jacobi_tr
        !! Extract transpose of Jacobi matrix from a vector of dual or hyper-dual numbers.
        !! - A hyper-dual vector results in a dual matrix.
        !! - A dual vector results in a real matrix.
      #:for type_spec in type_specs
        #:set type_suffix, has_hdual = dnad.decode_type_spec(type_spec)
        module procedure jacobi_tr__d_${type_suffix}$
       #:if has_hdual
        module procedure jacobi_tr__hd_${type_suffix}$
       #:endif
      #:endfor
    end interface
#:enddef

#:def dnad_jacobi_tr_implementations(type_specs, real_kind)
  #:for type_spec in type_specs
    #:set type_suffix, has_hdual = dnad.decode_type_spec(type_spec)
    pure function jacobi_tr__d_${type_suffix}$(x) result(y)
        type(dual__${type_suffix}$_t), intent(in) :: x(:)
        real(${real_kind}$) :: y(size(x(1)%g),size(x))

        integer :: j

        do j = 1, size(x)
            y(:,j) = x(j)%g
        end do

    end function
   #:if has_hdual
    pure function jacobi_tr__hd_${type_suffix}$(x) result(y)
        type(hdual__${type_suffix}$_t), intent(in) :: x(:)
        type(dual__${type_suffix}$_t) :: y(size(x(1)%d%g),size(x))

        real(${real_kind}$) :: hess(size(x(1)%d%g), size(x(1)%d%g))
        integer :: i, j

        do j = 1, size(x)
            hess = hessian(x(j))
            do i = 1, size(x(1)%d%g)
                y(i,j)%f = x(j)%d%g(i)
                y(i,j)%g = hess(:,i)
            end do
        end do

    end function
   #:endif
  #:endfor
#:enddef
