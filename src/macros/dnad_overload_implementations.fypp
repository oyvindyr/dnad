#! Include implementations from the macros/overload_implementations directory.
#! File names ending with _gen.fypp are generated by Python from Sympy expressions
#!
#:include 'assign.fypp'
#:include 'add_gen.fypp'
#:include 'minus_gen.fypp'
#:include 'mult_gen.fypp'
#:include 'div_gen.fypp'
#:include 'pow.fypp'
#:include 'eq.fypp'
#:include 'le.fypp'
#:include 'lt.fypp'
#:include 'ge.fypp'
#:include 'gt.fypp'
#:include 'ne.fypp'

#:include 'log_gen.fypp'
#:include 'sqrt.fypp'

#!
#!
#:def dnad_overload_implementations(real_kind, &
        dual_types = [], dual_shortnames = [], dual_sizes = [], &
        hdual_types = [], hdual_shortnames = [], hdual_sizes = [], &
        selected_interfaces="--all", stringent=True, is_pure=True, test_coverage=False) 
#!
#:assert len(dual_types) > 0 or len(hdual_types) > 0
#:assert len(dual_types) == len(dual_shortnames)
#:assert len(dual_types) == len(dual_sizes)
#:assert len(hdual_types) == len(hdual_shortnames)
#:assert len(hdual_types) == len(hdual_sizes)
#! 
#:set interface_list = dnad.select_interfaces(selected_interfaces)
#!
#:if is_pure and not test_coverage
    #:set elemental_purity = "elemental"
    #:set purity = "pure"
#:else
    #:set elemental_purity = "impure elemental"
    #:set purity = ""
#:endif
#!
#!
#:if "=" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:assign_d(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:assign_hd(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#!
#!
#:if "+" in interface_list
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:add_d( dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:add_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif
#!
#! 
#:if "-" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:minus_d( dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:minus_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif 
#!
#! 
#:if "*" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:mult_d(dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:mult_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif 
#!
#! 
#:if "/" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:div_d(dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:div_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif 
#!
#! 
#:if "**" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:pow_d(dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:pow_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif 
#!
#! 
#:if "==" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:eq(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:eq(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if "<=" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:le(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:le(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if "<" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:lt(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:lt(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if ">=" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:ge(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:ge(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if ">" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:gt(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:gt(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if "/=" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    $:ne(dual_type, dual_sn, real_kind, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn in zip(hdual_types, hdual_shortnames)
    $:ne(hdual_type, hdual_sn, real_kind, is_pure, test_coverage)
  #:endfor
#:endif 
#:if "abs" in interface_list or "dabs" in interface_list
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    ${elemental_purity}$  function abs_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res
        integer :: i

        ! We need this!
      #:if stringent == True
        if (u%x == 0) then
            res%x = 0.0_${real_kind}$
            do i = 1, ${dual_size}$
                if (u%dx(i) .eq. 0.0_${real_kind}$) then
                    res%dx(i) = 0.0_${real_kind}$
                else
                    res%dx(i) = set_NaN()
                end if
            end do
        else 
            res%x = abs(u%x)
            res%dx = abs(u%dx)
        end if
      #:else 
        res%x = abs(u%x)
        res%dx = abs(u%dx)
      #:endif

    end function
  #:endfor
#:endif 
#:if "acos" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function acos_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = acos(u%x)
    
      #:if stringent == True
        if (u%x == 1.0_${real_kind}$ .or. u%x == -1.0_${real_kind}$) then
            res%dx = set_Nan()  ! Undefined derivative
        else
            res%dx = -u%dx / sqrt(1.0_${real_kind}$ - u%x**2)
        end if
      #:else 
        res%dx = -u%dx / sqrt(1.0_${real_kind}$ - u%x**2)
      #:endif

    end function
  #:endfor
#:endif 
#:if "asin" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function asin_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = asin(u%x)
      #:if stringent == True
        if (u%x == 1.0_${real_kind}$ .or. u%x == -1.0_${real_kind}$) then
            res%dx = set_NaN()  ! Undefined derivative
        else
            res%dx = u%dx / sqrt(1.0_${real_kind}$ - u%x**2)
        end if
      #:else 
        res%dx = u%dx / sqrt(1.0_${real_kind}$ - u%x**2)
      #:endif

    end function
  #:endfor
#:endif 
#:if "atan" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function atan_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = atan(u%x)
        res%dx = u%dx / (1.0_${real_kind}$ + u%x**2)

    end function
  #:endfor
#:endif 
#:if "atan2" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function atan2_${dual_sn}$(u, v) result(res)
        type(${dual_type}$), intent(in) :: u, v
        type(${dual_type}$) :: res

        real(${real_kind}$) :: usq_plus_vsq

        res%x = atan2(u%x, v%x)

        usq_plus_vsq = u%x**2 + v%x**2
        res%dx = v%x / usq_plus_vsq * u%dx - u%x / usq_plus_vsq * v%dx

    end function
  #:endfor
#:endif 
#:if "cos" in interface_list or "dcos" in interface_list
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function cos_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = cos(u%x)
        res%dx = -sin(u%x) * u%dx

    end function
  #:endfor
#:endif 
#:if "dot_product" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    ${purity}$  function dot_product_${dual_sn}$_${dual_sn}$(u, v) result(res)
        type(${dual_type}$), intent(in) :: u(:), v(:)
        type(${dual_type}$) :: res

        integer :: i

        res%x = dot_product(u%x, v%x)
        do i = 1, ${dual_size}$
            res%dx(i) = dot_product(u%x, v%dx(i)) + dot_product(v%x, u%dx(i))
        end do

    end function
  #:endfor
#:endif 
#:if "exp" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function exp_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        real(${real_kind}$) :: exp_x

        exp_x = exp(u%x)
        res%x = exp_x
        res%dx = u%dx * exp_x

    end function
  #:endfor
#:endif 
#:if "int" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function int_${dual_sn}$(u) result(res)
         type(${dual_type}$), intent(in) :: u
         integer :: res

         res = int(u%x)

    end function
  #:endfor
#:endif 
#:if "log" in interface_list
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:log_d(dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:log_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage)
  #:endfor
#:endif 
#:if "log10" in interface_list
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function log10_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        real(${real_kind}$) :: inv

        inv = 1.0_${real_kind}$ / (u%x * log(10.0_${real_kind}$))
        res%x = log10(u%x)
        res%dx = u%dx * inv

    end function
  #:endfor
#:endif 
#:if "matmul" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    ${purity}$  function matmul_${dual_sn}$_${dual_sn}$(u,v) result(res)
        type(${dual_type}$), intent(in) :: u(:,:), v(:,:)
        type(${dual_type}$) :: res(size(u,1), size(v,2))

        integer :: i

        res%x = matmul(u%x, v%x)
        do i = 1, ${dual_size}$
            res%dx(i) = matmul(u%dx(i), v%x) + matmul(u%x, v%dx(i))
        end do

    end function
    ${purity}$  function matmul_${dual_sn}$_v(u, v) result(res)
        type(${dual_type}$), intent(in) :: u(:,:), v(:)
        type(${dual_type}$) :: res(size(u,1))
        integer :: i

        res%x = matmul(u%x, v%x)
        do i = 1, ${dual_size}$
            res%dx(i) = matmul(u%dx(i), v%x) + matmul(u%x, v%dx(i))
        end do

    end function
    ${purity}$  function matmul_v_${dual_sn}$(u, v) result(res)
        type(${dual_type}$), intent(in) :: u(:), v(:,:)
        type(${dual_type}$) :: res(size(v, 2))
        integer::i

        res%x = matmul(u%x, v%x)
        do i = 1, ${dual_size}$
            res%dx(i) = matmul(u%dx(i), v%x) + matmul(u%x, v%dx(i))
        end do

    end function
  #:endfor
#:endif 
#:if "max" in interface_list
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function max_${dual_sn}$_${dual_sn}$(val1, val2) result(res)
        type(${dual_type}$), intent(in) :: val1, val2
        type(${dual_type}$) :: res

        if (val1%x > val2%x) then
            res = val1
        else
            res = val2
        endif

    end function
    ${elemental_purity}$  function max_${dual_sn}$_i(u, i) result(res)
        type(${dual_type}$), intent(in) :: u
        integer, intent(in) :: i
        type(${dual_type}$) :: res

        if (u%x > i) then
            res = u
        else
            res = i
        endif

    end function
    ${elemental_purity}$  function max_${dual_sn}$_r(u, r) result(res)
        type(${dual_type}$), intent(in) :: u
        real(${real_kind}$), intent(in) :: r
        type(${dual_type}$) :: res

        if (u%x > r) then
            res = u
        else
            res = r
        endif

    end function
     ${elemental_purity}$  function max_r_${dual_sn}$(n, u) result(res)
        real(${real_kind}$), intent(in) :: n
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        if (u%x > n) then
            res = u
        else
            res = n
        endif

    end function
  #:endfor
#:endif 
#:if "dmax1" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function dmax1_${dual_sn}$_${dual_sn}$(val1, val2, val3, val4,val5) result(res)
        type(${dual_type}$), intent(in) :: val1, val2
        type(${dual_type}$), intent(in), optional :: val3, val4,val5
        type(${dual_type}$) :: res

        if (val1%x > val2%x) then
            res = val1
        else
            res = val2
        endif
        if(present(val3))then
           if(res%x < val3%x) res = val3
        endif
        if(present(val4))then
           if(res%x < val4%x) res = val4
        endif
        if(present(val5))then
           if(res%x < val5%x) res = val5
        endif

    end function
  #:endfor
#:endif 
#:if "maxval" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${purity}$  function maxval_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u(:)
        integer :: iloc(1)
        type(${dual_type}$) :: res

        iloc=maxloc(u%x)
        res=u(iloc(1))

    end function
  #:endfor
#:endif 
#:if "min" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function min_${dual_sn}$_${dual_sn}$(val1, val2) result(res)
        type(${dual_type}$), intent(in) :: val1, val2
        type(${dual_type}$) :: res

        if (val1%x < val2%x) then
            res = val1
        else
            res = val2
        endif

    end function
    ${elemental_purity}$  function min_${dual_sn}$_r(u, r) result(res)
        type(${dual_type}$), intent(in) :: u
        real(${real_kind}$), intent(in) :: r
        type(${dual_type}$) :: res

        if (u%x < r) then
            res = u
        else
            res = r
        endif

    end function
  #:endfor
#:endif 
#:if "dmin1" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function dmin1_${dual_sn}$_${dual_sn}$(val1, val2, val3, val4) result(res)
        type(${dual_type}$), intent(in) :: val1, val2
        type(${dual_type}$), intent(in), optional :: val3, val4
        type(${dual_type}$) :: res

        if (val1%x < val2%x) then
            res = val1
        else
            res = val2
        endif
        if(present(val3))then
           if(res%x > val3%x) res = val3
        endif
        if(present(val4))then
           if(res%x > val4%x) res = val4
        endif

    end function
  #:endfor
#:endif 
#:if "minval" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${purity}$  function minval_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u(:)
        integer :: iloc(1)
        type(${dual_type}$) :: res

        iloc=minloc(u%x)
        res=u(iloc(1))

    end function
  #:endfor
#:endif 
#:if "nint" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function nint_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        integer :: res

        res=nint(u%x)

    end function
  #:endfor
#:endif 
#:if "sign" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function sign_${dual_sn}$_${dual_sn}$(val1, val2) result(res)
        type(${dual_type}$), intent(in) :: val1, val2
        type(${dual_type}$) :: res

        if (val2%x < 0.0_${real_kind}$) then
            res = -abs(val1)
        else
            res =  abs(val1)
        endif

     end function
    ${elemental_purity}$  function sign_r_${dual_sn}$(val1, val2) result(res)
        real(${real_kind}$), intent(in) :: val1
        type(${dual_type}$), intent(in) :: val2
        type(${dual_type}$) :: res

        if (val2%x < 0.0_${real_kind}$) then
            res = -abs(val1)
        else
            res = abs(val1)
        endif

     end function
  #:endfor
#:endif 
#:if "sin" in interface_list or "dsin" in interface_list
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function sin_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = sin(u%x)
        res%dx = cos(u%x) * u%dx

    end function
  #:endfor
#:endif 
#:if "tan" in interface_list or "dtan" in interface_list
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${elemental_purity}$  function tan_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u
        type(${dual_type}$) :: res

        res%x = tan(u%x)
        res%dx = u%dx / cos(u%x)**2

    end function
  #:endfor
#:endif 
#:if "sqrt" in interface_list
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    $:sqrt_d(dual_type, dual_sn, real_kind, dual_size, is_pure, test_coverage, stringent)
  #:endfor
  #:for hdual_type, hdual_sn, hdual_size in zip(hdual_types, hdual_shortnames, hdual_sizes)
    $:sqrt_hd(hdual_type, hdual_sn, real_kind, hdual_size, is_pure, test_coverage, stringent)
  #:endfor
#:endif 
#:if "sum" in interface_list 
  #:for dual_type, dual_sn, dual_size in zip(dual_types, dual_shortnames, dual_sizes)
    ${purity}$  function sum_${dual_sn}$(u) result(res)
        type(${dual_type}$), intent(in) :: u(:)
        type(${dual_type}$) :: res
        integer :: i

        res%x = sum(u%x)
        do i = 1, ${dual_size}$
            res%dx(i) = sum(u%dx(i))
        end do

    end function
  #:endfor
#:endif 
#:if "maxloc" in interface_list 
  #:for dual_type, dual_sn in zip(dual_types, dual_shortnames)
    ${purity}$  function maxloc_${dual_sn}$(array) result(ind)
        type(${dual_type}$), intent(in) :: array(:)
        integer :: ind(1)

        ind = maxloc(array%x)

    end function
  #:endfor
#:endif 
#:enddef 
