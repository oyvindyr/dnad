
#:def dnad_chain_duals_interface(chain_types_specs)
    interface chain_duals
        !! Generic function for converting a dual or hyper-dual number from one dual-type to another by applying the chain rule of derivation
        module procedure chain_duals__real
      #:for chain_types_spec in chain_types_specs
        #:set y_type_suffix, x_type_suffix, has_hdual = dnad.decode_chain_types_spec(chain_types_spec)
        module procedure chain_duals__d_${y_type_suffix}$_${x_type_suffix}$
       #:if has_hdual
        module procedure chain_duals__hd_${y_type_suffix}$_${x_type_suffix}$
       #:endif
      #:endfor
    end interface
#:enddef

#:def dnad_chain_duals_implementations(chain_types_specs, real_kind)
    $:dnad_chain_duals_implementation_r(real_kind)
    #:for chain_types_spec in chain_types_specs
        #:set y_type_suffix, x_type_suffix, has_hdual = dnad.decode_chain_types_spec(chain_types_spec)
        $:dnad_chain_duals_implementation_d(y_type_suffix, x_type_suffix, real_kind)
        #:if has_hdual
            $:dnad_chain_duals_implementation_hd(y_type_suffix, x_type_suffix, real_kind)
        #:endif
    #:endfor
#:enddef

#:def dnad_chain_duals_implementation_r(real_kind)
    #:set _THIS_FILE_NAME_ = _THIS_FILE_[max(_THIS_FILE_.rindex('\\'), _THIS_FILE_.rindex('/'))+1:]
    #:set headerlines = [&
        '!! Dummy function acting as a generalization of chain_duals for real numbers.', &
        ' ', &
        '! This function has been automatically generated by ' + _THIS_FILE_NAME_]
    #!
    pure function chain_duals__real(fy, yx) result(fx)
      #:for headerline in headerlines
        ${headerline}$
      #:endfor
        real(${real_kind}$), intent(in) :: fy
        real(${real_kind}$), intent(in) :: yx(:)
        real(${real_kind}$) :: fx

        fx = fy

    end function
#:enddef

#:def dnad_chain_duals_implementation_d(y_type_suffix, x_type_suffix, real_kind)
    #! Write chain_duals implementation. Note that the hessian function is assumed to be available. This should be inserted into the 
    #! same file as this function by a separate dnad macro
    #!
    #:set _THIS_FILE_NAME_ = _THIS_FILE_[max(_THIS_FILE_.rindex('\\'), _THIS_FILE_.rindex('/'))+1:]
    #!
    #:set dual_y_type = "dual__" + y_type_suffix + "_t"
    #:set dual_x_type = "dual__" + x_type_suffix + "_t"
    #:set headerlines = [&
        '!! Convert a function value from type('+dual_y_type+') to type('+dual_x_type+')', &
        '!! by applying the chain rule of derivation. Second input yx(:) has type('+dual_x_type+')', &
        '!! and represents the design variables by which the derivatives of fy is taken with respect to.', &
        '!! Thus, size(yx) needs to be equal to size(fy%g) (size known at compile time).', &
        ' ', &
        '! This function has been automatically generated by ' + _THIS_FILE_NAME_]
    #!
    pure function chain_duals__d_${y_type_suffix}$_${x_type_suffix}$(fy, yx) result(fx)
      #:for headerline in headerlines
        ${headerline}$
      #:endfor
        type(${dual_y_type}$), intent(in) :: fy
        type(${dual_x_type}$), intent(in) :: yx(:)
        type(${dual_x_type}$) :: fx
        
        integer :: p, j

        fx%f = fy%f
        fx%g = 0
        do p = 1, size(fy%g)
            do j = 1, size(fx%g)
                fx%g(j) = fx%g(j) + fy%g(p)*yx(p)%g(j)
            end do
        end do

    end function
#:enddef

#:def dnad_chain_duals_implementation_hd(y_type_suffix, x_type_suffix, real_kind)
    #! Write chain_duals implementation. Note that the hessian function is assumed to be available. This should be inserted into the 
    #! same file as this function by a separate dnad macro
    #!
    #:set _THIS_FILE_NAME_ = _THIS_FILE_[max(_THIS_FILE_.rindex('\\'), _THIS_FILE_.rindex('/'))+1:]
    #!
    #:set dual_y_type = "hdual__" + y_type_suffix + "_t"
    #:set dual_x_type = "hdual__" + x_type_suffix + "_t"
    #:set headerlines = [&
        '!! Convert a function value from type('+dual_y_type+') to type('+dual_x_type+')', &
        '!! by applying the chain rule of derivation. Second input yx(:) has type('+dual_x_type+')', &
        '!! and represents the design variables by which the derivatives of fy is taken with respect to.', &
        '!! Thus, size(yx) needs to be equal to size(fy%d%g) (size known at compile time).', &
        ' ', &
        '! This function has been automatically generated by ' + _THIS_FILE_NAME_]
    #!
    pure function chain_duals__hd_${y_type_suffix}$_${x_type_suffix}$(fy, yx) result(fx)
      #:for headerline in headerlines
        ${headerline}$
      #:endfor
        type(${dual_y_type}$), intent(in) :: fy
        type(${dual_x_type}$), intent(in) :: yx(:)
        type(${dual_x_type}$) :: fx
        
        integer :: p, j
        integer :: i, q, k, nk
        real(${real_kind}$) :: hfy(size(fy%d%g), size(fy%d%g))
        real(${real_kind}$) :: tmp

        ! Calculate dual part
        fx%d%f = fy%d%f
        fx%d%g = 0
        do p = 1, size(fy%d%g)
            do j = 1, size(fx%d%g)
                fx%d%g(j) = fx%d%g(j) + fy%d%g(p)*yx(p)%d%g(j)
            end do
        end do

        ! Calculate hessian part
        nk = size(fx%d%g)*(size(fx%d%g)+1)/2
        fx%h = 0
        do p = 1, size(fy%d%g)
            do k = 1, nk
                fx%h(k) = fx%h(k) + fy%d%g(p)*yx(p)%h(k)
            end do
        end do
        hfy = hessian(fy)
        do q = 1, size(fy%d%g)
            do p = 1, size(fy%d%g)
                k = 0
                do j = 1, size(fx%d%g)
                    tmp = hfy(p,q)*yx(q)%d%g(j)
                    do i = j, size(fx%d%g)
                        k = k + 1
                        fx%h(k) = fx%h(k) + tmp*yx(p)%d%g(i)
                    end do
                end do
            end do
        end do

    end function
#:enddef
