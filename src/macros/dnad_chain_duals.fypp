
#:def dnad_chain_duals_interface(chain_types_specs)
    interface chain_duals
        !! Generic function for converting a dual or hyper-dual number from one dual-type to another by applying the chain rule of derivation
      #:for chain_types_spec in chain_types_specs
        #:set y_type_suffix, x_type_suffix, has_hdual = dnad.decode_chain_types_spec(chain_types_spec)
        module procedure chain_duals__d_${y_type_suffix}$_${x_type_suffix}$
       #:if has_hdual
        module procedure chain_duals__hd_${y_type_suffix}$_${x_type_suffix}$
       #:endif
      #:endfor
    end interface
#:enddef

#:def dnad_chain_duals_implementations(chain_types_specs, real_kind)
    #:for chain_types_spec in chain_types_specs
        #:set y_type_suffix, x_type_suffix, has_hdual = dnad.decode_chain_types_spec(chain_types_spec)
        #:if has_hdual
            $:dnad_chain_duals_implementation(y_type_suffix, x_type_suffix, False, real_kind)
            $:dnad_chain_duals_implementation(y_type_suffix, x_type_suffix, True, real_kind)
        #:else
            $:dnad_chain_duals_implementation(y_type_suffix, x_type_suffix, False, real_kind)
        #:endif
    #:endfor
#:enddef

#:def dnad_chain_duals_implementation(y_type_suffix, x_type_suffix, is_hyper_dual, real_kind)
    #! Write chain_duals implementation. Note that the hessian function is assumed to be available. This should be inserted into the 
    #! same file as this function by a separate dnad macro
    #!
    #:set _THIS_FILE_NAME_ = _THIS_FILE_[max(_THIS_FILE_.rindex('\\'), _THIS_FILE_.rindex('/'))+1:]
    #!
  #:if is_hyper_dual
    #:set dual_y_type = "hdual__" + y_type_suffix + "_t"
    #:set dual_x_type = "hdual__" + x_type_suffix + "_t"
    #:set sn = "hd"
  #:else
    #:set dual_y_type = "dual__" + y_type_suffix + "_t"
    #:set dual_x_type = "dual__" + x_type_suffix + "_t"
    #:set sn = "d"
  #:endif
    #:set headerlines = [&
        '!! Convert a function value from type('+dual_y_type+') to type('+dual_x_type+')', &
        '!! by applying the chain rule of derivation. Second input yx(:) has type('+dual_x_type+')', &
        '!! and represents the design variables by which the derivatives of fy is taken with respect to.', &
        '!! Thus, size(yx) needs to be equal to size(fy%g) (size known at compile time).', &
        ' ', &
        '! This function has been automatically generated by ' + _THIS_FILE_NAME_]
    #!
    pure function chain_duals__${sn}$_${y_type_suffix}$_${x_type_suffix}$(fy, yx) result(fx)
      #:for headerline in headerlines
        ${headerline}$
      #:endfor
      #:if is_hyper_dual
        #:set f = "d%f"
        #:set g = "d%g"
      #:else
        #:set f = "f"
        #:set g = "g"
      #:endif
        type(${dual_y_type}$), intent(in) :: fy
        type(${dual_x_type}$), intent(in) :: yx(size(fy%${g}$))
        type(${dual_x_type}$) :: fx
        
        integer :: p, j
      #:if is_hyper_dual
        integer :: i, q, k, nk
        real(${real_kind}$) :: hfy(size(fy%${g}$), size(fy%${g}$))
        real(${real_kind}$) :: tmp
      #:endif

        fx%${f}$ = fy%${f}$
        fx%${g}$ = 0
        do p = 1, size(fy%${g}$)
            do j = 1, size(fx%${g}$)
                fx%${g}$(j) = fx%${g}$(j) + fy%${g}$(p)*yx(p)%${g}$(j)
            end do
        end do

      #:if is_hyper_dual
        nk = size(fx%${g}$)*(size(fx%${g}$)+1)/2
        fx%h = 0
        do p = 1, size(fy%${g}$)
            do k = 1, nk
                fx%h(k) = fx%h(k) + fy%${g}$(p)*yx(p)%h(k)
            end do
        end do
        hfy = hessian(fy)
        do q = 1, size(fy%${g}$)
            do p = 1, size(fy%${g}$)
                k = 0
                do j = 1, size(fx%${g}$)
                    tmp = hfy(p,q)*yx(q)%${g}$(j)
                    do i = j, size(fx%${g}$)
                        k = k + 1
                        fx%h(k) = fx%h(k) + tmp*yx(p)%${g}$(i)
                    end do
                end do
            end do
        end do
      #:endif

    end function
#:enddef
