
#:def dnad_chain_duals_interface(dual_y_names, dual_x_names)
    #! Write interface for one or more chain_duals implementations
    #!
    #:assert len(dual_y_names) == len(dual_x_names)
    #!
    interface chain_duals
        !! Generic function for converting a dual or hyper-dual number from one dual-type to another by applying the chain rule of derivation
      #:for dual_y_name, dual_x_name in zip(dual_y_names, dual_x_names)
        module procedure chain_duals__${dual_y_name}$_${dual_x_name}$
      #:endfor
    end interface
#:enddef


#:def dnad_chain_duals_implementation(dual_y_type, dual_y_name, dual_x_type, dual_x_name, is_hyper_dual = False)
    #! Write chain_duals implementation. Note that the hessian function is assumed to be available. This should be inserted into the 
    #! same file as this function by a separate dnad macro
    #!
    #:set _THIS_FILE_NAME_ = _THIS_FILE_[max(_THIS_FILE_.rindex('\\'), _THIS_FILE_.rindex('/'))+1:]
    #!
    #:set headerlines = [&
        '!! Convert a function value from type('+dual_y_type+') to type('+dual_x_type+')', &
        '!! by applying the chain rule of derivation. Second input yx(:) has type('+dual_x_type+')', &
        '!! and represents the design variables by which the derivatives of fy is taken with respect to.', &
        '!! Thus, size(yx) needs to be equal to size(fy%dx) (size known at compile time).', &
        ' ', &
        '! This function has been automatically generated by ' + _THIS_FILE_NAME_]
    #!
    pure function chain_duals__${dual_y_name}$_${dual_x_name}$(fy, yx) result(fx)

        type(${dual_y_type}$), intent(in) :: fy
        type(${dual_x_type}$), intent(in) :: yx(size(fy%dx))
        type(${dual_x_type}$) :: fx
        
        integer :: p, j
      #:if is_hyper_dual
        integer :: i, q, k, nk
        real(dp) :: hfy(size(fy%dx), size(fy%dx))
        real(dp) :: tmp
      #:endif

        fx%x = fy%x
        fx%dx = 0
        do p = 1, size(fy%dx)
            do j = 1, size(fx%dx)
                fx%dx(j) = fx%dx(j) + fy%dx(p)*yx(p)%dx(j)
            end do
        end do

      #:if is_hyper_dual
        nk = size(fx%dx)*(size(fx%dx)+1)/2
        fx%ddx = 0
        do p = 1, size(fy%dx)
            do k = 1, nk
                fx%ddx(k) = fx%ddx(k) + fy%dx(p)*yx(p)%ddx(k)
            end do
        end do
        hfy = hessian(fy)
        do q = 1, size(fy%dx)
            do p = 1, size(fy%dx)
                k = 0
                do j = 1, size(fx%dx)
                    tmp = hfy(p,q)*yx(q)%dx(j)
                    do i = j, size(fx%dx)
                        k = k + 1
                        fx%ddx(k) = fx%ddx(k) + tmp*yx(p)%dx(i)
                    end do
                end do
            end do
        end do
      #:endif

    end function
#:enddef
